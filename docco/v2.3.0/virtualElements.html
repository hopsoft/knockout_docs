<!DOCTYPE html>

<html>
<head>
  <title>virtualElements.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="bindingAttributeSyntax.html">
                bindingAttributeSyntax.js
              </a>
            
              
              <a class="source" href="bindingProvider.html">
                bindingProvider.js
              </a>
            
              
              <a class="source" href="attr.html">
                attr.js
              </a>
            
              
              <a class="source" href="checked.html">
                checked.js
              </a>
            
              
              <a class="source" href="click.html">
                click.js
              </a>
            
              
              <a class="source" href="css.html">
                css.js
              </a>
            
              
              <a class="source" href="enableDisable.html">
                enableDisable.js
              </a>
            
              
              <a class="source" href="event.html">
                event.js
              </a>
            
              
              <a class="source" href="foreach.html">
                foreach.js
              </a>
            
              
              <a class="source" href="hasfocus.html">
                hasfocus.js
              </a>
            
              
              <a class="source" href="html.html">
                html.js
              </a>
            
              
              <a class="source" href="ifIfnotWith.html">
                ifIfnotWith.js
              </a>
            
              
              <a class="source" href="options.html">
                options.js
              </a>
            
              
              <a class="source" href="selectedOptions.html">
                selectedOptions.js
              </a>
            
              
              <a class="source" href="style.html">
                style.js
              </a>
            
              
              <a class="source" href="submit.html">
                submit.js
              </a>
            
              
              <a class="source" href="text.html">
                text.js
              </a>
            
              
              <a class="source" href="uniqueName.html">
                uniqueName.js
              </a>
            
              
              <a class="source" href="value.html">
                value.js
              </a>
            
              
              <a class="source" href="visible.html">
                visible.js
              </a>
            
              
              <a class="source" href="arrayToDomNodeChildren.html">
                arrayToDomNodeChildren.js
              </a>
            
              
              <a class="source" href="compareArrays.html">
                compareArrays.js
              </a>
            
              
              <a class="source" href="expressionRewriting.html">
                expressionRewriting.js
              </a>
            
              
              <a class="source" href="selectExtensions.html">
                selectExtensions.js
              </a>
            
              
              <a class="source" href="google-closure-compiler-utils.html">
                google-closure-compiler-utils.js
              </a>
            
              
              <a class="source" href="memoization.html">
                memoization.js
              </a>
            
              
              <a class="source" href="namespace.html">
                namespace.js
              </a>
            
              
              <a class="source" href="dependencyDetection.html">
                dependencyDetection.js
              </a>
            
              
              <a class="source" href="dependentObservable.html">
                dependentObservable.js
              </a>
            
              
              <a class="source" href="extenders.html">
                extenders.js
              </a>
            
              
              <a class="source" href="mappingHelpers.html">
                mappingHelpers.js
              </a>
            
              
              <a class="source" href="observable.html">
                observable.js
              </a>
            
              
              <a class="source" href="observableArray.html">
                observableArray.js
              </a>
            
              
              <a class="source" href="subscribable.html">
                subscribable.js
              </a>
            
              
              <a class="source" href="jqueryTmplTemplateEngine.html">
                jqueryTmplTemplateEngine.js
              </a>
            
              
              <a class="source" href="nativeTemplateEngine.html">
                nativeTemplateEngine.js
              </a>
            
              
              <a class="source" href="templateEngine.html">
                templateEngine.js
              </a>
            
              
              <a class="source" href="templateRewriting.html">
                templateRewriting.js
              </a>
            
              
              <a class="source" href="templateSources.html">
                templateSources.js
              </a>
            
              
              <a class="source" href="templating.html">
                templating.js
              </a>
            
              
              <a class="source" href="utils.domData.html">
                utils.domData.js
              </a>
            
              
              <a class="source" href="utils.domManipulation.html">
                utils.domManipulation.js
              </a>
            
              
              <a class="source" href="utils.domNodeDisposal.html">
                utils.domNodeDisposal.js
              </a>
            
              
              <a class="source" href="utils.html">
                utils.js
              </a>
            
              
              <a class="source" href="version.html">
                version.js
              </a>
            
              
              <a class="source" href="virtualElements.html">
                virtualElements.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>virtualElements.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="keyword">function</span>() {</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>&quot;Virtual elements&quot; is an abstraction on top of the usual DOM API which understands the notion that comment nodes
may be used to represent hierarchy (in addition to the DOM&#39;s natural hierarchy).
If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state
of that virtual hierarchy</p>
<p>The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)
without having to scatter special cases all over the binding and templating code.</p>
<p>IE 9 cannot reliably read the &quot;nodeValue&quot; property of a comment node (see <a href="https://github.com/SteveSanderson/knockout/issues/186">https://github.com/SteveSanderson/knockout/issues/186</a>)
but it does give them a nonstandard alternative property called &quot;text&quot; that it can read reliably. Other browsers don&#39;t have that property.
So, use node.text where available, and node.nodeValue elsewhere</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> commentNodesHaveTextProperty = document &amp;&amp; document.createComment(<span class="string">"test"</span>).text === <span class="string">"&lt;!--test--&gt;"</span>;

    <span class="keyword">var</span> startCommentRegex = commentNodesHaveTextProperty ? <span class="regexp">/^&lt;!--\s*ko(?:\s+(.+\s*\:[\s\S]*))?\s*--&gt;$/</span> : <span class="regexp">/^\s*ko(?:\s+(.+\s*\:[\s\S]*))?\s*$/</span>;
    <span class="keyword">var</span> endCommentRegex =   commentNodesHaveTextProperty ? <span class="regexp">/^&lt;!--\s*\/ko\s*--&gt;$/</span> : <span class="regexp">/^\s*\/ko\s*$/</span>;
    <span class="keyword">var</span> htmlTagsWithOptionallyClosingChildren = { <span class="string">'ul'</span>: <span class="literal">true</span>, <span class="string">'ol'</span>: <span class="literal">true</span> };

    <span class="function"><span class="keyword">function</span> <span class="title">isStartComment</span><span class="params">(node)</span> {</span>
        <span class="keyword">return</span> (node.nodeType == <span class="number">8</span>) &amp;&amp; (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);
    }

    <span class="function"><span class="keyword">function</span> <span class="title">isEndComment</span><span class="params">(node)</span> {</span>
        <span class="keyword">return</span> (node.nodeType == <span class="number">8</span>) &amp;&amp; (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(endCommentRegex);
    }

    <span class="function"><span class="keyword">function</span> <span class="title">getVirtualChildren</span><span class="params">(startComment, allowUnbalanced)</span> {</span>
        <span class="keyword">var</span> currentNode = startComment;
        <span class="keyword">var</span> depth = <span class="number">1</span>;
        <span class="keyword">var</span> children = [];
        <span class="keyword">while</span> (currentNode = currentNode.nextSibling) {
            <span class="keyword">if</span> (isEndComment(currentNode)) {
                depth--;
                <span class="keyword">if</span> (depth === <span class="number">0</span>)
                    <span class="keyword">return</span> children;
            }

            children.push(currentNode);

            <span class="keyword">if</span> (isStartComment(currentNode))
                depth++;
        }
        <span class="keyword">if</span> (!allowUnbalanced)
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Cannot find closing comment tag to match: "</span> + startComment.nodeValue);
        <span class="keyword">return</span> <span class="literal">null</span>;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">getMatchingEndComment</span><span class="params">(startComment, allowUnbalanced)</span> {</span>
        <span class="keyword">var</span> allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);
        <span class="keyword">if</span> (allVirtualChildren) {
            <span class="keyword">if</span> (allVirtualChildren.length &gt; <span class="number">0</span>)
                <span class="keyword">return</span> allVirtualChildren[allVirtualChildren.length - <span class="number">1</span>].nextSibling;
            <span class="keyword">return</span> startComment.nextSibling;
        } <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// Must have no matching end comment, and allowUnbalanced is true</span>
    }

    <span class="function"><span class="keyword">function</span> <span class="title">getUnbalancedChildTags</span><span class="params">(node)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>
      from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko --></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> childNode = node.firstChild, captureRemaining = <span class="literal">null</span>;
        <span class="keyword">if</span> (childNode) {
            <span class="keyword">do</span> {
                <span class="keyword">if</span> (captureRemaining)                   <span class="comment">// We already hit an unbalanced node and are now just scooping up all subsequent nodes</span>
                    captureRemaining.push(childNode);
                <span class="keyword">else</span> <span class="keyword">if</span> (isStartComment(childNode)) {
                    <span class="keyword">var</span> matchingEndComment = getMatchingEndComment(childNode, <span class="comment">/* allowUnbalanced: */</span> <span class="literal">true</span>);
                    <span class="keyword">if</span> (matchingEndComment)             <span class="comment">// It's a balanced tag, so skip immediately to the end of this virtual set</span>
                        childNode = matchingEndComment;
                    <span class="keyword">else</span>
                        captureRemaining = [childNode]; <span class="comment">// It's unbalanced, so start capturing from this point</span>
                } <span class="keyword">else</span> <span class="keyword">if</span> (isEndComment(childNode)) {
                    captureRemaining = [childNode];     <span class="comment">// It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing</span>
                }
            } <span class="keyword">while</span> (childNode = childNode.nextSibling);
        }
        <span class="keyword">return</span> captureRemaining;
    }

    ko.virtualElements = {
        allowedBindings: {},

        childNodes: <span class="keyword">function</span>(node) {
            <span class="keyword">return</span> isStartComment(node) ? getVirtualChildren(node) : node.childNodes;
        },

        emptyNode: <span class="keyword">function</span>(node) {
            <span class="keyword">if</span> (!isStartComment(node))
                ko.utils.emptyDomNode(node);
            <span class="keyword">else</span> {
                <span class="keyword">var</span> virtualChildren = ko.virtualElements.childNodes(node);
                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = virtualChildren.length; i &lt; j; i++)
                    ko.removeNode(virtualChildren[i]);
            }
        },

        setDomNodeChildren: <span class="keyword">function</span>(node, childNodes) {
            <span class="keyword">if</span> (!isStartComment(node))
                ko.utils.setDomNodeChildren(node, childNodes);
            <span class="keyword">else</span> {
                ko.virtualElements.emptyNode(node);
                <span class="keyword">var</span> endCommentNode = node.nextSibling; <span class="comment">// Must be the next sibling, as we just emptied the children</span>
                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = childNodes.length; i &lt; j; i++)
                    endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);
            }
        },

        prepend: <span class="keyword">function</span>(containerNode, nodeToPrepend) {
            <span class="keyword">if</span> (!isStartComment(containerNode)) {
                <span class="keyword">if</span> (containerNode.firstChild)
                    containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);
                <span class="keyword">else</span>
                    containerNode.appendChild(nodeToPrepend);
            } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Start comments must always have a parent and at least one following sibling (the end comment)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);
            }
        },

        insertAfter: <span class="keyword">function</span>(containerNode, nodeToInsert, insertAfterNode) {
            <span class="keyword">if</span> (!insertAfterNode) {
                ko.virtualElements.prepend(containerNode, nodeToInsert);
            } <span class="keyword">else</span> <span class="keyword">if</span> (!isStartComment(containerNode)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Insert after insertion point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (insertAfterNode.nextSibling)
                    containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
                <span class="keyword">else</span>
                    containerNode.appendChild(nodeToInsert);
            } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Children of start comments must always have a parent and at least one following sibling (the end comment)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
            }
        },

        firstChild: <span class="keyword">function</span>(node) {
            <span class="keyword">if</span> (!isStartComment(node))
                <span class="keyword">return</span> node.firstChild;
            <span class="keyword">if</span> (!node.nextSibling || isEndComment(node.nextSibling))
                <span class="keyword">return</span> <span class="literal">null</span>;
            <span class="keyword">return</span> node.nextSibling;
        },

        nextSibling: <span class="keyword">function</span>(node) {
            <span class="keyword">if</span> (isStartComment(node))
                node = getMatchingEndComment(node);
            <span class="keyword">if</span> (node.nextSibling &amp;&amp; isEndComment(node.nextSibling))
                <span class="keyword">return</span> <span class="literal">null</span>;
            <span class="keyword">return</span> node.nextSibling;
        },

        virtualNodeBindingValue: <span class="keyword">function</span>(node) {
            <span class="keyword">var</span> regexMatch = isStartComment(node);
            <span class="keyword">return</span> regexMatch ? regexMatch[<span class="number">1</span>] : <span class="literal">null</span>;
        },

        normaliseVirtualElementDomStructure: <span class="keyword">function</span>(elementVerified) {</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Workaround for <a href="https://github.com/SteveSanderson/knockout/issues/155">https://github.com/SteveSanderson/knockout/issues/155</a>
(IE &lt;= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don&#39;t exist, thereby moving comment nodes
that are direct descendants of <ul> into the preceding <li>)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])
                <span class="keyword">return</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags
must be intended to appear <em>after</em> that child, so move them there.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> childNode = elementVerified.firstChild;
            <span class="keyword">if</span> (childNode) {
                <span class="keyword">do</span> {
                    <span class="keyword">if</span> (childNode.nodeType === <span class="number">1</span>) {
                        <span class="keyword">var</span> unbalancedTags = getUnbalancedChildTags(childNode);
                        <span class="keyword">if</span> (unbalancedTags) {</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - <em>after</em> the child</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            <span class="keyword">var</span> nodeToInsertBefore = childNode.nextSibling;
                            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; unbalancedTags.length; i++) {
                                <span class="keyword">if</span> (nodeToInsertBefore)
                                    elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);
                                <span class="keyword">else</span>
                                    elementVerified.appendChild(unbalancedTags[i]);
                            }
                        }
                    }
                } <span class="keyword">while</span> (childNode = childNode.nextSibling);
            }
        }
    };
})();
ko.exportSymbol(<span class="string">'virtualElements'</span>, ko.virtualElements);
ko.exportSymbol(<span class="string">'virtualElements.allowedBindings'</span>, ko.virtualElements.allowedBindings);
ko.exportSymbol(<span class="string">'virtualElements.emptyNode'</span>, ko.virtualElements.emptyNode);</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>ko.exportSymbol(&#39;virtualElements.firstChild&#39;, ko.virtualElements.firstChild);     // firstChild is not minified</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>ko.exportSymbol(<span class="string">'virtualElements.insertAfter'</span>, ko.virtualElements.insertAfter);</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>ko.exportSymbol(&#39;virtualElements.nextSibling&#39;, ko.virtualElements.nextSibling);   // nextSibling is not minified</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>ko.exportSymbol(<span class="string">'virtualElements.prepend'</span>, ko.virtualElements.prepend);
ko.exportSymbol(<span class="string">'virtualElements.setDomNodeChildren'</span>, ko.virtualElements.setDomNodeChildren);</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
