<!DOCTYPE html>

<html>
<head>
  <title>arrayToDomNodeChildren.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="bindingAttributeSyntax.html">
                bindingAttributeSyntax.js
              </a>
            
              
              <a class="source" href="bindingProvider.html">
                bindingProvider.js
              </a>
            
              
              <a class="source" href="attr.html">
                attr.js
              </a>
            
              
              <a class="source" href="checked.html">
                checked.js
              </a>
            
              
              <a class="source" href="click.html">
                click.js
              </a>
            
              
              <a class="source" href="css.html">
                css.js
              </a>
            
              
              <a class="source" href="enableDisable.html">
                enableDisable.js
              </a>
            
              
              <a class="source" href="event.html">
                event.js
              </a>
            
              
              <a class="source" href="foreach.html">
                foreach.js
              </a>
            
              
              <a class="source" href="hasfocus.html">
                hasfocus.js
              </a>
            
              
              <a class="source" href="html.html">
                html.js
              </a>
            
              
              <a class="source" href="ifIfnotWith.html">
                ifIfnotWith.js
              </a>
            
              
              <a class="source" href="options.html">
                options.js
              </a>
            
              
              <a class="source" href="selectedOptions.html">
                selectedOptions.js
              </a>
            
              
              <a class="source" href="style.html">
                style.js
              </a>
            
              
              <a class="source" href="submit.html">
                submit.js
              </a>
            
              
              <a class="source" href="text.html">
                text.js
              </a>
            
              
              <a class="source" href="uniqueName.html">
                uniqueName.js
              </a>
            
              
              <a class="source" href="value.html">
                value.js
              </a>
            
              
              <a class="source" href="visible.html">
                visible.js
              </a>
            
              
              <a class="source" href="arrayToDomNodeChildren.html">
                arrayToDomNodeChildren.js
              </a>
            
              
              <a class="source" href="compareArrays.html">
                compareArrays.js
              </a>
            
              
              <a class="source" href="expressionRewriting.html">
                expressionRewriting.js
              </a>
            
              
              <a class="source" href="selectExtensions.html">
                selectExtensions.js
              </a>
            
              
              <a class="source" href="google-closure-compiler-utils.html">
                google-closure-compiler-utils.js
              </a>
            
              
              <a class="source" href="memoization.html">
                memoization.js
              </a>
            
              
              <a class="source" href="namespace.html">
                namespace.js
              </a>
            
              
              <a class="source" href="dependencyDetection.html">
                dependencyDetection.js
              </a>
            
              
              <a class="source" href="dependentObservable.html">
                dependentObservable.js
              </a>
            
              
              <a class="source" href="extenders.html">
                extenders.js
              </a>
            
              
              <a class="source" href="mappingHelpers.html">
                mappingHelpers.js
              </a>
            
              
              <a class="source" href="observable.html">
                observable.js
              </a>
            
              
              <a class="source" href="observableArray.html">
                observableArray.js
              </a>
            
              
              <a class="source" href="subscribable.html">
                subscribable.js
              </a>
            
              
              <a class="source" href="jqueryTmplTemplateEngine.html">
                jqueryTmplTemplateEngine.js
              </a>
            
              
              <a class="source" href="nativeTemplateEngine.html">
                nativeTemplateEngine.js
              </a>
            
              
              <a class="source" href="templateEngine.html">
                templateEngine.js
              </a>
            
              
              <a class="source" href="templateRewriting.html">
                templateRewriting.js
              </a>
            
              
              <a class="source" href="templateSources.html">
                templateSources.js
              </a>
            
              
              <a class="source" href="templating.html">
                templating.js
              </a>
            
              
              <a class="source" href="utils.domData.html">
                utils.domData.js
              </a>
            
              
              <a class="source" href="utils.domManipulation.html">
                utils.domManipulation.js
              </a>
            
              
              <a class="source" href="utils.domNodeDisposal.html">
                utils.domNodeDisposal.js
              </a>
            
              
              <a class="source" href="utils.html">
                utils.js
              </a>
            
              
              <a class="source" href="version.html">
                version.js
              </a>
            
              
              <a class="source" href="virtualElements.html">
                virtualElements.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>arrayToDomNodeChildren.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Objective:
<em> Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,
  map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node
</em> Next time we&#39;re given the same combination of things (with the array possibly having mutated), update the container DOM node
  so that its children is again the concatenation of the mappings of the array elements, but don&#39;t re-map any array elements that we
  previously mapped - retain those nodes, and just insert/delete other ones</p>
<p>&quot;callbackAfterAddingNodes&quot; will be invoked after any &quot;mapping&quot;-generated nodes are inserted into the container node
You can use this, for example, to activate bindings on those nodes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">fixUpNodesToBeMovedOrRemoved</span><span class="params">(contiguousNodeArray)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Before moving, deleting, or replacing a set of nodes that were previously outputted by the &quot;map&quot; function, we have to reconcile
them against what is in the DOM right now. It may be that some of the nodes have already been removed from the document,
or that new nodes might have been inserted in the middle, for example by a binding. Also, there may previously have been
leading comment nodes (created by rewritten string-based templates) that have since been removed during binding.
So, this function translates the old &quot;map&quot; output array into its best guess of what set of current DOM nodes should be removed.</p>
<p>Rules:
  [A] Any leading nodes that aren&#39;t in the document any more should be ignored
      These most likely correspond to memoization nodes that were already removed during binding
      See <a href="https://github.com/SteveSanderson/knockout/pull/440">https://github.com/SteveSanderson/knockout/pull/440</a>
  [B] We want to output a contiguous series of nodes that are still in the document. So, ignore any nodes that
      have already been removed, and include any nodes that have been inserted among the previous collection</p>
<p>Rule [A]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">while</span> (contiguousNodeArray.length &amp;&amp; !ko.utils.domNodeIsAttachedToDocument(contiguousNodeArray[<span class="number">0</span>]))
            contiguousNodeArray.splice(<span class="number">0</span>, <span class="number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Rule [B]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (contiguousNodeArray.length &gt; <span class="number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Build up the actual new contiguous node set</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> current = contiguousNodeArray[<span class="number">0</span>], last = contiguousNodeArray[contiguousNodeArray.length - <span class="number">1</span>], newContiguousSet = [current];
            <span class="keyword">while</span> (current !== last) {
                current = current.nextSibling;
                <span class="keyword">if</span> (!current) <span class="comment">// Won't happen, except if the developer has manually removed some DOM elements (then we're in an undefined scenario)</span>
                    <span class="keyword">return</span>;
                newContiguousSet.push(current);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>... then mutate the input array to match this.
(The following line replaces the contents of contiguousNodeArray with newContiguousSet)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            Array.prototype.splice.apply(contiguousNodeArray, [<span class="number">0</span>, contiguousNodeArray.length].concat(newContiguousSet));
        }
        <span class="keyword">return</span> contiguousNodeArray;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">mapNodeAndRefreshWhenChanged</span><span class="params">(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Map this array value inside a dependentObservable so we re-map when any dependency changes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> mappedNodes = [];
        <span class="keyword">var</span> dependentObservable = ko.dependentObservable(<span class="keyword">function</span>() {
            <span class="keyword">var</span> newMappedNodes = mapping(valueToMap, index, fixUpNodesToBeMovedOrRemoved(mappedNodes)) || [];</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>On subsequent evaluations, just replace the previously-inserted DOM nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (mappedNodes.length &gt; <span class="number">0</span>) {
                ko.utils.replaceDomNodes(mappedNodes, newMappedNodes);
                <span class="keyword">if</span> (callbackAfterAddingNodes)
                    ko.dependencyDetection.ignore(callbackAfterAddingNodes, <span class="literal">null</span>, [valueToMap, newMappedNodes, index]);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Replace the contents of the mappedNodes array, thereby updating the record
of which nodes would be deleted if valueToMap was itself later removed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            mappedNodes.splice(<span class="number">0</span>, mappedNodes.length);
            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);
        }, <span class="literal">null</span>, { disposeWhenNodeIsRemoved: containerNode, disposeWhen: <span class="keyword">function</span>() { <span class="keyword">return</span> !ko.utils.anyDomNodeIsAttachedToDocument(mappedNodes); } });
        <span class="keyword">return</span> { mappedNodes : mappedNodes, dependentObservable : (dependentObservable.isActive() ? dependentObservable : <span class="literal">undefined</span>) };
    }

    <span class="keyword">var</span> lastMappingResultDomDataKey = <span class="string">"setDomNodeChildrenFromArrayMapping_lastMappingResult"</span>;

    ko.utils.setDomNodeChildrenFromArrayMapping = <span class="function"><span class="keyword">function</span> <span class="params">(domNode, array, mapping, options, callbackAfterAddingNodes)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Compare the provided array against the previous one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        array = array || [];
        options = options || {};
        <span class="keyword">var</span> isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === <span class="literal">undefined</span>;
        <span class="keyword">var</span> lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];
        <span class="keyword">var</span> lastArray = ko.utils.arrayMap(lastMappingResult, <span class="function"><span class="keyword">function</span> <span class="params">(x)</span> {</span> <span class="keyword">return</span> x.arrayEntry; });
        <span class="keyword">var</span> editScript = ko.utils.compareArrays(lastArray, array, options[<span class="string">'dontLimitMoves'</span>]);</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Build the new mapping result</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> newMappingResult = [];
        <span class="keyword">var</span> lastMappingResultIndex = <span class="number">0</span>;
        <span class="keyword">var</span> newMappingResultIndex = <span class="number">0</span>;

        <span class="keyword">var</span> nodesToDelete = [];
        <span class="keyword">var</span> itemsToProcess = [];
        <span class="keyword">var</span> itemsForBeforeRemoveCallbacks = [];
        <span class="keyword">var</span> itemsForMoveCallbacks = [];
        <span class="keyword">var</span> itemsForAfterAddCallbacks = [];
        <span class="keyword">var</span> mapData;

        <span class="function"><span class="keyword">function</span> <span class="title">itemMovedOrRetained</span><span class="params">(editScriptIndex, oldPosition)</span> {</span>
            mapData = lastMappingResult[oldPosition];
            <span class="keyword">if</span> (newMappingResultIndex !== oldPosition)
                itemsForMoveCallbacks[editScriptIndex] = mapData;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Since updating the index might change the nodes, do so before calling fixUpNodesToBeMovedOrRemoved</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            mapData.indexObservable(newMappingResultIndex++);
            fixUpNodesToBeMovedOrRemoved(mapData.mappedNodes);
            newMappingResult.push(mapData);
            itemsToProcess.push(mapData);
        }

        <span class="function"><span class="keyword">function</span> <span class="title">callCallback</span><span class="params">(callback, items)</span> {</span>
            <span class="keyword">if</span> (callback) {
                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, n = items.length; i &lt; n; i++) {
                    <span class="keyword">if</span> (items[i]) {
                        ko.utils.arrayForEach(items[i].mappedNodes, <span class="keyword">function</span>(node) {
                            callback(node, i, items[i].arrayEntry);
                        });
                    }
                }
            }
        }

        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, editScriptItem, movedIndex; editScriptItem = editScript[i]; i++) {
            movedIndex = editScriptItem[<span class="string">'moved'</span>];
            <span class="keyword">switch</span> (editScriptItem[<span class="string">'status'</span>]) {
                <span class="keyword">case</span> <span class="string">"deleted"</span>:
                    <span class="keyword">if</span> (movedIndex === <span class="literal">undefined</span>) {
                        mapData = lastMappingResult[lastMappingResultIndex];</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Stop tracking changes to the mapping for these nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        <span class="keyword">if</span> (mapData.dependentObservable)
                            mapData.dependentObservable.dispose();</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Queue these nodes for later removal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        nodesToDelete.push.apply(nodesToDelete, fixUpNodesToBeMovedOrRemoved(mapData.mappedNodes));
                        <span class="keyword">if</span> (options[<span class="string">'beforeRemove'</span>]) {
                            itemsForBeforeRemoveCallbacks[i] = mapData;
                            itemsToProcess.push(mapData);
                        }
                    }
                    lastMappingResultIndex++;
                    <span class="keyword">break</span>;

                <span class="keyword">case</span> <span class="string">"retained"</span>:
                    itemMovedOrRetained(i, lastMappingResultIndex++);
                    <span class="keyword">break</span>;

                <span class="keyword">case</span> <span class="string">"added"</span>:
                    <span class="keyword">if</span> (movedIndex !== <span class="literal">undefined</span>) {
                        itemMovedOrRetained(i, movedIndex);
                    } <span class="keyword">else</span> {
                        mapData = { arrayEntry: editScriptItem[<span class="string">'value'</span>], indexObservable: ko.observable(newMappingResultIndex++) };
                        newMappingResult.push(mapData);
                        itemsToProcess.push(mapData);
                        <span class="keyword">if</span> (!isFirstExecution)
                            itemsForAfterAddCallbacks[i] = mapData;
                    }
                    <span class="keyword">break</span>;
            }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Call beforeMove first before any changes have been made to the DOM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        callCallback(options[<span class="string">'beforeMove'</span>], itemsForMoveCallbacks);</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Next remove nodes for deleted items (or just clean if there&#39;s a beforeRemove callback)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        ko.utils.arrayForEach(nodesToDelete, options[<span class="string">'beforeRemove'</span>] ? ko.cleanNode : ko.removeNode);</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Next add/reorder the remaining items (will include deleted items if there&#39;s a beforeRemove callback)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, nextNode = ko.virtualElements.firstChild(domNode), lastNode, node; mapData = itemsToProcess[i]; i++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Get nodes for newly added items</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (!mapData.mappedNodes)
                ko.utils.extend(mapData, mapNodeAndRefreshWhenChanged(domNode, mapping, mapData.arrayEntry, callbackAfterAddingNodes, mapData.indexObservable));</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Put nodes in the right place if they aren&#39;t there already</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; node = mapData.mappedNodes[j]; nextNode = node.nextSibling, lastNode = node, j++) {
                <span class="keyword">if</span> (node !== nextNode)
                    ko.virtualElements.insertAfter(domNode, node, lastNode);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Run the callbacks for newly added nodes (for example, to apply bindings, etc.)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (!mapData.initialized &amp;&amp; callbackAfterAddingNodes) {
                callbackAfterAddingNodes(mapData.arrayEntry, mapData.mappedNodes, mapData.indexObservable);
                mapData.initialized = <span class="literal">true</span>;
            }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>If there&#39;s a beforeRemove callback, call it after reordering.
Note that we assume that the beforeRemove callback will usually be used to remove the nodes using
some sort of animation, which is why we first reorder the nodes that will be removed. If the
callback instead removes the nodes right away, it would be more efficient to skip reordering them.
Perhaps we&#39;ll make that change in the future if this scenario becomes more common.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        callCallback(options[<span class="string">'beforeRemove'</span>], itemsForBeforeRemoveCallbacks);</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Finally call afterMove and afterAdd callbacks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        callCallback(options[<span class="string">'afterMove'</span>], itemsForMoveCallbacks);
        callCallback(options[<span class="string">'afterAdd'</span>], itemsForAfterAddCallbacks);</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Store a copy of the array items we just considered so we can difference it next time</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);
    }
})();

ko.exportSymbol(<span class="string">'utils.setDomNodeChildrenFromArrayMapping'</span>, ko.utils.setDomNodeChildrenFromArrayMapping);</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
