<!DOCTYPE html>

<html>
<head>
  <title>templating.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="bindingAttributeSyntax.html">
                bindingAttributeSyntax.js
              </a>
            
              
              <a class="source" href="bindingProvider.html">
                bindingProvider.js
              </a>
            
              
              <a class="source" href="attr.html">
                attr.js
              </a>
            
              
              <a class="source" href="checked.html">
                checked.js
              </a>
            
              
              <a class="source" href="click.html">
                click.js
              </a>
            
              
              <a class="source" href="css.html">
                css.js
              </a>
            
              
              <a class="source" href="enableDisable.html">
                enableDisable.js
              </a>
            
              
              <a class="source" href="event.html">
                event.js
              </a>
            
              
              <a class="source" href="foreach.html">
                foreach.js
              </a>
            
              
              <a class="source" href="hasfocus.html">
                hasfocus.js
              </a>
            
              
              <a class="source" href="html.html">
                html.js
              </a>
            
              
              <a class="source" href="ifIfnotWith.html">
                ifIfnotWith.js
              </a>
            
              
              <a class="source" href="options.html">
                options.js
              </a>
            
              
              <a class="source" href="selectedOptions.html">
                selectedOptions.js
              </a>
            
              
              <a class="source" href="style.html">
                style.js
              </a>
            
              
              <a class="source" href="submit.html">
                submit.js
              </a>
            
              
              <a class="source" href="text.html">
                text.js
              </a>
            
              
              <a class="source" href="uniqueName.html">
                uniqueName.js
              </a>
            
              
              <a class="source" href="value.html">
                value.js
              </a>
            
              
              <a class="source" href="visible.html">
                visible.js
              </a>
            
              
              <a class="source" href="arrayToDomNodeChildren.html">
                arrayToDomNodeChildren.js
              </a>
            
              
              <a class="source" href="compareArrays.html">
                compareArrays.js
              </a>
            
              
              <a class="source" href="expressionRewriting.html">
                expressionRewriting.js
              </a>
            
              
              <a class="source" href="selectExtensions.html">
                selectExtensions.js
              </a>
            
              
              <a class="source" href="google-closure-compiler-utils.html">
                google-closure-compiler-utils.js
              </a>
            
              
              <a class="source" href="memoization.html">
                memoization.js
              </a>
            
              
              <a class="source" href="namespace.html">
                namespace.js
              </a>
            
              
              <a class="source" href="dependencyDetection.html">
                dependencyDetection.js
              </a>
            
              
              <a class="source" href="dependentObservable.html">
                dependentObservable.js
              </a>
            
              
              <a class="source" href="extenders.html">
                extenders.js
              </a>
            
              
              <a class="source" href="mappingHelpers.html">
                mappingHelpers.js
              </a>
            
              
              <a class="source" href="observable.html">
                observable.js
              </a>
            
              
              <a class="source" href="observableArray.html">
                observableArray.js
              </a>
            
              
              <a class="source" href="subscribable.html">
                subscribable.js
              </a>
            
              
              <a class="source" href="jqueryTmplTemplateEngine.html">
                jqueryTmplTemplateEngine.js
              </a>
            
              
              <a class="source" href="nativeTemplateEngine.html">
                nativeTemplateEngine.js
              </a>
            
              
              <a class="source" href="templateEngine.html">
                templateEngine.js
              </a>
            
              
              <a class="source" href="templateRewriting.html">
                templateRewriting.js
              </a>
            
              
              <a class="source" href="templateSources.html">
                templateSources.js
              </a>
            
              
              <a class="source" href="templating.html">
                templating.js
              </a>
            
              
              <a class="source" href="utils.domData.html">
                utils.domData.js
              </a>
            
              
              <a class="source" href="utils.domManipulation.html">
                utils.domManipulation.js
              </a>
            
              
              <a class="source" href="utils.domNodeDisposal.html">
                utils.domNodeDisposal.js
              </a>
            
              
              <a class="source" href="utils.html">
                utils.js
              </a>
            
              
              <a class="source" href="version.html">
                version.js
              </a>
            
              
              <a class="source" href="virtualElements.html">
                virtualElements.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>templating.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> _templateEngine;
    ko.setTemplateEngine = <span class="function"><span class="keyword">function</span> <span class="params">(templateEngine)</span> {</span>
        <span class="keyword">if</span> ((templateEngine != <span class="literal">undefined</span>) &amp;&amp; !(templateEngine <span class="keyword">instanceof</span> ko.templateEngine))
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"templateEngine must inherit from ko.templateEngine"</span>);
        _templateEngine = templateEngine;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">invokeForEachNodeOrCommentInContinuousRange</span><span class="params">(firstNode, lastNode, action)</span> {</span>
        <span class="keyword">var</span> node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);
        <span class="keyword">while</span> (nextInQueue &amp;&amp; ((node = nextInQueue) !== firstOutOfRangeNode)) {
            nextInQueue = ko.virtualElements.nextSibling(node);
            <span class="keyword">if</span> (node.nodeType === <span class="number">1</span> || node.nodeType === <span class="number">8</span>)
                action(node);
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">activateBindingsOnContinuousNodeArray</span><span class="params">(continuousNodeArray, bindingContext)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>To be used on any nodes that have been rendered by a template and have been inserted into some parent element
Walks through continuousNodeArray (which <em>must</em> be continuous, i.e., an uninterrupted sequence of sibling nodes, because
the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,
(1) Does a regular &quot;applyBindings&quot; to associate bindingContext with this node and to activate any non-memoized bindings
(2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (continuousNodeArray.length) {
            <span class="keyword">var</span> firstNode = continuousNodeArray[<span class="number">0</span>], lastNode = continuousNodeArray[continuousNodeArray.length - <span class="number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Need to applyBindings <em>before</em> unmemoziation, because unmemoization might introduce extra nodes (that we don&#39;t want to re-bind)
whereas a regular applyBindings won&#39;t introduce new memoized nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, <span class="keyword">function</span>(node) {
                ko.applyBindings(bindingContext, node);
            });
            invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, <span class="keyword">function</span>(node) {
                ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);
            });
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">getFirstNodeFromPossibleArray</span><span class="params">(nodeOrNodeArray)</span> {</span>
        <span class="keyword">return</span> nodeOrNodeArray.nodeType ? nodeOrNodeArray
                                        : nodeOrNodeArray.length &gt; <span class="number">0</span> ? nodeOrNodeArray[<span class="number">0</span>]
                                        : <span class="literal">null</span>;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">executeTemplate</span><span class="params">(targetNodeOrNodeArray, renderMode, template, bindingContext, options)</span> {</span>
        options = options || {};
        <span class="keyword">var</span> firstTargetNode = targetNodeOrNodeArray &amp;&amp; getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
        <span class="keyword">var</span> templateDocument = firstTargetNode &amp;&amp; firstTargetNode.ownerDocument;
        <span class="keyword">var</span> templateEngineToUse = (options[<span class="string">'templateEngine'</span>] || _templateEngine);
        ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);
        <span class="keyword">var</span> renderedNodesArray = templateEngineToUse[<span class="string">'renderTemplate'</span>](template, bindingContext, options, templateDocument);</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Loosely check result is an array of DOM nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> ((<span class="keyword">typeof</span> renderedNodesArray.length != <span class="string">"number"</span>) || (renderedNodesArray.length &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">typeof</span> renderedNodesArray[<span class="number">0</span>].nodeType != <span class="string">"number"</span>))
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Template engine must return an array of DOM nodes"</span>);

        <span class="keyword">var</span> haveAddedNodesToParent = <span class="literal">false</span>;
        <span class="keyword">switch</span> (renderMode) {
            <span class="keyword">case</span> <span class="string">"replaceChildren"</span>:
                ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);
                haveAddedNodesToParent = <span class="literal">true</span>;
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"replaceNode"</span>:
                ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);
                haveAddedNodesToParent = <span class="literal">true</span>;
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"ignoreTargetNode"</span>: <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Unknown renderMode: "</span> + renderMode);
        }

        <span class="keyword">if</span> (haveAddedNodesToParent) {
            activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);
            <span class="keyword">if</span> (options[<span class="string">'afterRender'</span>])
                ko.dependencyDetection.ignore(options[<span class="string">'afterRender'</span>], <span class="literal">null</span>, [renderedNodesArray, bindingContext[<span class="string">'$data'</span>]]);
        }

        <span class="keyword">return</span> renderedNodesArray;
    }

    ko.renderTemplate = <span class="function"><span class="keyword">function</span> <span class="params">(template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode)</span> {</span>
        options = options || {};
        <span class="keyword">if</span> ((options[<span class="string">'templateEngine'</span>] || _templateEngine) == <span class="literal">undefined</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Set a template engine before calling renderTemplate"</span>);
        renderMode = renderMode || <span class="string">"replaceChildren"</span>;

        <span class="keyword">if</span> (targetNodeOrNodeArray) {
            <span class="keyword">var</span> firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);

            <span class="keyword">var</span> whenToDispose = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="keyword">return</span> (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; <span class="comment">// Passive disposal (on next evaluation)</span>
            <span class="keyword">var</span> activelyDisposeWhenNodeIsRemoved = (firstTargetNode &amp;&amp; renderMode == <span class="string">"replaceNode"</span>) ? firstTargetNode.parentNode : firstTargetNode;

            <span class="keyword">return</span> ko.dependentObservable( <span class="comment">// So the DOM is automatically updated when any dependency changes</span>
                <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Ensure we&#39;ve got a proper binding context to work with</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">var</span> bindingContext = (dataOrBindingContext &amp;&amp; (dataOrBindingContext <span class="keyword">instanceof</span> ko.bindingContext))
                        ? dataOrBindingContext
                        : <span class="keyword">new</span> ko.bindingContext(ko.utils.unwrapObservable(dataOrBindingContext));</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Support selecting template as a function of the data being rendered</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">var</span> templateName = <span class="keyword">typeof</span>(template) == <span class="string">'function'</span> ? template(bindingContext[<span class="string">'$data'</span>], bindingContext) : template;

                    <span class="keyword">var</span> renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);
                    <span class="keyword">if</span> (renderMode == <span class="string">"replaceNode"</span>) {
                        targetNodeOrNodeArray = renderedNodesArray;
                        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
                    }
                },
                <span class="literal">null</span>,
                { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }
            );
        } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>We don&#39;t yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">return</span> ko.memoization.memoize(<span class="function"><span class="keyword">function</span> <span class="params">(domNode)</span> {</span>
                ko.renderTemplate(template, dataOrBindingContext, options, domNode, <span class="string">"replaceNode"</span>);
            });
        }
    };

    ko.renderTemplateForEach = <span class="function"><span class="keyword">function</span> <span class="params">(template, arrayOrObservableArray, options, targetNode, parentBindingContext)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then
activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> arrayItemContext;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> executeTemplateForArrayItem = <span class="function"><span class="keyword">function</span> <span class="params">(arrayValue, index)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Support selecting template as a function of the data being rendered</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            arrayItemContext = parentBindingContext[<span class="string">'createChildContext'</span>](ko.utils.unwrapObservable(arrayValue), options[<span class="string">'as'</span>]);
            arrayItemContext[<span class="string">'$index'</span>] = index;
            <span class="keyword">var</span> templateName = <span class="keyword">typeof</span>(template) == <span class="string">'function'</span> ? template(arrayValue, arrayItemContext) : template;
            <span class="keyword">return</span> executeTemplate(<span class="literal">null</span>, <span class="string">"ignoreTargetNode"</span>, templateName, arrayItemContext, options);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> activateBindingsCallback = <span class="keyword">function</span>(arrayValue, addedNodesArray, index) {
            activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);
            <span class="keyword">if</span> (options[<span class="string">'afterRender'</span>])
                options[<span class="string">'afterRender'</span>](addedNodesArray, arrayValue);
        };

        <span class="keyword">return</span> ko.dependentObservable(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">var</span> unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];
            <span class="keyword">if</span> (<span class="keyword">typeof</span> unwrappedArray.length == <span class="string">"undefined"</span>) <span class="comment">// Coerce single value into array</span>
                unwrappedArray = [unwrappedArray];</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Filter out any entries marked as destroyed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> filteredArray = ko.utils.arrayFilter(unwrappedArray, <span class="keyword">function</span>(item) {
                <span class="keyword">return</span> options[<span class="string">'includeDestroyed'</span>] || item === <span class="literal">undefined</span> || item === <span class="literal">null</span> || !ko.utils.unwrapObservable(item[<span class="string">'_destroy'</span>]);
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).
If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            ko.dependencyDetection.ignore(ko.utils.setDomNodeChildrenFromArrayMapping, <span class="literal">null</span>, [targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback]);

        }, <span class="literal">null</span>, { disposeWhenNodeIsRemoved: targetNode });
    };

    <span class="keyword">var</span> templateComputedDomDataKey = <span class="string">'__ko__templateComputedDomDataKey__'</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">disposeOldComputedAndStoreNewOne</span><span class="params">(element, newComputed)</span> {</span>
        <span class="keyword">var</span> oldComputed = ko.utils.domData.get(element, templateComputedDomDataKey);
        <span class="keyword">if</span> (oldComputed &amp;&amp; (<span class="keyword">typeof</span>(oldComputed.dispose) == <span class="string">'function'</span>))
            oldComputed.dispose();
        ko.utils.domData.set(element, templateComputedDomDataKey, (newComputed &amp;&amp; newComputed.isActive()) ? newComputed : <span class="literal">undefined</span>);
    }

    ko.bindingHandlers[<span class="string">'template'</span>] = {
        <span class="string">'init'</span>: <span class="keyword">function</span>(element, valueAccessor) {</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Support anonymous templates</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> bindingValue = ko.utils.unwrapObservable(valueAccessor());
            <span class="keyword">if</span> ((<span class="keyword">typeof</span> bindingValue != <span class="string">"string"</span>) &amp;&amp; (!bindingValue[<span class="string">'name'</span>]) &amp;&amp; (element.nodeType == <span class="number">1</span> || element.nodeType == <span class="number">8</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>It&#39;s an anonymous template - store the element contents, then clear the element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> templateNodes = element.nodeType == <span class="number">1</span> ? element.childNodes : ko.virtualElements.childNodes(element),
                    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); <span class="comment">// This also removes the nodes from their current parent</span>
                <span class="keyword">new</span> ko.templateSources.anonymousTemplate(element)[<span class="string">'nodes'</span>](container);
            }
            <span class="keyword">return</span> { <span class="string">'controlsDescendantBindings'</span>: <span class="literal">true</span> };
        },
        <span class="string">'update'</span>: <span class="function"><span class="keyword">function</span> <span class="params">(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext)</span> {</span>
            <span class="keyword">var</span> templateName = ko.utils.unwrapObservable(valueAccessor()),
                options = {},
                shouldDisplay = <span class="literal">true</span>,
                dataValue,
                templateComputed = <span class="literal">null</span>;

            <span class="keyword">if</span> (<span class="keyword">typeof</span> templateName != <span class="string">"string"</span>) {
                options = templateName;
                templateName = ko.utils.unwrapObservable(options[<span class="string">'name'</span>]);</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Support &quot;if&quot;/&quot;ifnot&quot; conditions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (<span class="string">'if'</span> <span class="keyword">in</span> options)
                    shouldDisplay = ko.utils.unwrapObservable(options[<span class="string">'if'</span>]);
                <span class="keyword">if</span> (shouldDisplay &amp;&amp; <span class="string">'ifnot'</span> <span class="keyword">in</span> options)
                    shouldDisplay = !ko.utils.unwrapObservable(options[<span class="string">'ifnot'</span>]);

                dataValue = ko.utils.unwrapObservable(options[<span class="string">'data'</span>]);
            }

            <span class="keyword">if</span> (<span class="string">'foreach'</span> <span class="keyword">in</span> options) {</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Render once for each data point (treating data set as empty if shouldDisplay==false)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> dataArray = (shouldDisplay &amp;&amp; options[<span class="string">'foreach'</span>]) || [];
                templateComputed = ko.renderTemplateForEach(templateName || element, dataArray, options, element, bindingContext);
            } <span class="keyword">else</span> <span class="keyword">if</span> (!shouldDisplay) {
                ko.virtualElements.emptyNode(element);
            } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Render once for this single data point (or use the viewModel if no data was provided)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> innerBindingContext = (<span class="string">'data'</span> <span class="keyword">in</span> options) ?
                    bindingContext[<span class="string">'createChildContext'</span>](dataValue, options[<span class="string">'as'</span>]) :  <span class="comment">// Given an explitit 'data' value, we create a child binding context for it</span>
                    bindingContext;                                                        <span class="comment">// Given no explicit 'data' value, we retain the same binding context</span>
                templateComputed = ko.renderTemplate(templateName || element, innerBindingContext, options, element);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>It only makes sense to have a single template computed per element (otherwise which one should have its output displayed?)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            disposeOldComputedAndStoreNewOne(element, templateComputed);
        }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Anonymous templates can&#39;t be rewritten. Give a nice error message if you try to do it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    ko.expressionRewriting.bindingRewriteValidators[<span class="string">'template'</span>] = <span class="keyword">function</span>(bindingValue) {
        <span class="keyword">var</span> parsedBindingValue = ko.expressionRewriting.parseObjectLiteral(bindingValue);

        <span class="keyword">if</span> ((parsedBindingValue.length == <span class="number">1</span>) &amp;&amp; parsedBindingValue[<span class="number">0</span>][<span class="string">'unknown'</span>])
            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)</span>

        <span class="keyword">if</span> (ko.expressionRewriting.keyValueArrayContainsKey(parsedBindingValue, <span class="string">"name"</span>))
            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// Named templates can be rewritten, so return "no error"</span>
        <span class="keyword">return</span> <span class="string">"This template engine does not support anonymous templates nested within its templates"</span>;
    };

    ko.virtualElements.allowedBindings[<span class="string">'template'</span>] = <span class="literal">true</span>;
})();

ko.exportSymbol(<span class="string">'setTemplateEngine'</span>, ko.setTemplateEngine);
ko.exportSymbol(<span class="string">'renderTemplate'</span>, ko.renderTemplate);</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
