<!DOCTYPE html>

<html>
<head>
  <title>bindingAttributeSyntax.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="bindingAttributeSyntax.html">
                bindingAttributeSyntax.js
              </a>
            
              
              <a class="source" href="bindingProvider.html">
                bindingProvider.js
              </a>
            
              
              <a class="source" href="attr.html">
                attr.js
              </a>
            
              
              <a class="source" href="checked.html">
                checked.js
              </a>
            
              
              <a class="source" href="click.html">
                click.js
              </a>
            
              
              <a class="source" href="css.html">
                css.js
              </a>
            
              
              <a class="source" href="enableDisable.html">
                enableDisable.js
              </a>
            
              
              <a class="source" href="event.html">
                event.js
              </a>
            
              
              <a class="source" href="foreach.html">
                foreach.js
              </a>
            
              
              <a class="source" href="hasfocus.html">
                hasfocus.js
              </a>
            
              
              <a class="source" href="html.html">
                html.js
              </a>
            
              
              <a class="source" href="ifIfnotWith.html">
                ifIfnotWith.js
              </a>
            
              
              <a class="source" href="options.html">
                options.js
              </a>
            
              
              <a class="source" href="selectedOptions.html">
                selectedOptions.js
              </a>
            
              
              <a class="source" href="style.html">
                style.js
              </a>
            
              
              <a class="source" href="submit.html">
                submit.js
              </a>
            
              
              <a class="source" href="text.html">
                text.js
              </a>
            
              
              <a class="source" href="uniqueName.html">
                uniqueName.js
              </a>
            
              
              <a class="source" href="value.html">
                value.js
              </a>
            
              
              <a class="source" href="visible.html">
                visible.js
              </a>
            
              
              <a class="source" href="arrayToDomNodeChildren.html">
                arrayToDomNodeChildren.js
              </a>
            
              
              <a class="source" href="compareArrays.html">
                compareArrays.js
              </a>
            
              
              <a class="source" href="expressionRewriting.html">
                expressionRewriting.js
              </a>
            
              
              <a class="source" href="selectExtensions.html">
                selectExtensions.js
              </a>
            
              
              <a class="source" href="google-closure-compiler-utils.html">
                google-closure-compiler-utils.js
              </a>
            
              
              <a class="source" href="memoization.html">
                memoization.js
              </a>
            
              
              <a class="source" href="namespace.html">
                namespace.js
              </a>
            
              
              <a class="source" href="dependencyDetection.html">
                dependencyDetection.js
              </a>
            
              
              <a class="source" href="dependentObservable.html">
                dependentObservable.js
              </a>
            
              
              <a class="source" href="extenders.html">
                extenders.js
              </a>
            
              
              <a class="source" href="mappingHelpers.html">
                mappingHelpers.js
              </a>
            
              
              <a class="source" href="observable.html">
                observable.js
              </a>
            
              
              <a class="source" href="observableArray.html">
                observableArray.js
              </a>
            
              
              <a class="source" href="subscribable.html">
                subscribable.js
              </a>
            
              
              <a class="source" href="jqueryTmplTemplateEngine.html">
                jqueryTmplTemplateEngine.js
              </a>
            
              
              <a class="source" href="nativeTemplateEngine.html">
                nativeTemplateEngine.js
              </a>
            
              
              <a class="source" href="templateEngine.html">
                templateEngine.js
              </a>
            
              
              <a class="source" href="templateRewriting.html">
                templateRewriting.js
              </a>
            
              
              <a class="source" href="templateSources.html">
                templateSources.js
              </a>
            
              
              <a class="source" href="templating.html">
                templating.js
              </a>
            
              
              <a class="source" href="utils.domData.html">
                utils.domData.js
              </a>
            
              
              <a class="source" href="utils.domManipulation.html">
                utils.domManipulation.js
              </a>
            
              
              <a class="source" href="utils.domNodeDisposal.html">
                utils.domNodeDisposal.js
              </a>
            
              
              <a class="source" href="utils.html">
                utils.js
              </a>
            
              
              <a class="source" href="version.html">
                version.js
              </a>
            
              
              <a class="source" href="virtualElements.html">
                virtualElements.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>bindingAttributeSyntax.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    ko.bindingHandlers = {};

    ko.bindingContext = <span class="keyword">function</span>(dataItem, parentBindingContext, dataItemAlias) {
        <span class="keyword">if</span> (parentBindingContext) {
            ko.utils.extend(<span class="keyword">this</span>, parentBindingContext); <span class="comment">// Inherit $root and any custom properties</span>
            <span class="keyword">this</span>[<span class="string">'$parentContext'</span>] = parentBindingContext;
            <span class="keyword">this</span>[<span class="string">'$parent'</span>] = parentBindingContext[<span class="string">'$data'</span>];
            <span class="keyword">this</span>[<span class="string">'$parents'</span>] = (parentBindingContext[<span class="string">'$parents'</span>] || []).slice(<span class="number">0</span>);
            <span class="keyword">this</span>[<span class="string">'$parents'</span>].unshift(<span class="keyword">this</span>[<span class="string">'$parent'</span>]);
        } <span class="keyword">else</span> {
            <span class="keyword">this</span>[<span class="string">'$parents'</span>] = [];
            <span class="keyword">this</span>[<span class="string">'$root'</span>] = dataItem;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Export &#39;ko&#39; in the binding context so it will be available in bindings and templates
even if &#39;ko&#39; isn&#39;t exported as a global, such as when using an AMD loader.
See <a href="https://github.com/SteveSanderson/knockout/issues/490">https://github.com/SteveSanderson/knockout/issues/490</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">this</span>[<span class="string">'ko'</span>] = ko;
        }
        <span class="keyword">this</span>[<span class="string">'$data'</span>] = dataItem;
        <span class="keyword">if</span> (dataItemAlias)
            <span class="keyword">this</span>[dataItemAlias] = dataItem;
    }
    ko.bindingContext.prototype[<span class="string">'createChildContext'</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(dataItem, dataItemAlias)</span> {</span>
        <span class="keyword">return</span> <span class="keyword">new</span> ko.bindingContext(dataItem, <span class="keyword">this</span>, dataItemAlias);
    };
    ko.bindingContext.prototype[<span class="string">'extend'</span>] = <span class="keyword">function</span>(properties) {
        <span class="keyword">var</span> clone = ko.utils.extend(<span class="keyword">new</span> ko.bindingContext(), <span class="keyword">this</span>);
        <span class="keyword">return</span> ko.utils.extend(clone, properties);
    };

    <span class="function"><span class="keyword">function</span> <span class="title">validateThatBindingIsAllowedForVirtualElements</span><span class="params">(bindingName)</span> {</span>
        <span class="keyword">var</span> validator = ko.virtualElements.allowedBindings[bindingName];
        <span class="keyword">if</span> (!validator)
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"The binding '"</span> + bindingName + <span class="string">"' cannot be used with virtual elements"</span>)
    }

    <span class="function"><span class="keyword">function</span> <span class="title">applyBindingsToDescendantsInternal</span> <span class="params">(viewModel, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement)</span> {</span>
        <span class="keyword">var</span> currentChild, nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);
        <span class="keyword">while</span> (currentChild = nextInQueue) {</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Keep a record of the next child <em>before</em> applying bindings, in case the binding removes the current child from its position</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            nextInQueue = ko.virtualElements.nextSibling(currentChild);
            applyBindingsToNodeAndDescendantsInternal(viewModel, currentChild, bindingContextsMayDifferFromDomParentElement);
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">applyBindingsToNodeAndDescendantsInternal</span> <span class="params">(viewModel, nodeVerified, bindingContextMayDifferFromDomParentElement)</span> {</span>
        <span class="keyword">var</span> shouldBindDescendants = <span class="literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Perf optimisation: Apply bindings only if...
(1) We need to store the binding context on this node (because it may differ from the DOM parent node&#39;s binding context)
    Note that we can&#39;t store binding contexts on non-elements (e.g., text nodes), as IE doesn&#39;t allow expando properties for those
(2) It might have bindings (e.g., it has a data-bind attribute, or it&#39;s a marker for a containerless template)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> isElement = (nodeVerified.nodeType === <span class="number">1</span>);
        <span class="keyword">if</span> (isElement) <span class="comment">// Workaround IE &lt;= 8 HTML parsing weirdness</span>
            ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);

        <span class="keyword">var</span> shouldApplyBindings = (isElement &amp;&amp; bindingContextMayDifferFromDomParentElement)             <span class="comment">// Case (1)</span>
                               || ko.bindingProvider[<span class="string">'instance'</span>][<span class="string">'nodeHasBindings'</span>](nodeVerified);       <span class="comment">// Case (2)</span>
        <span class="keyword">if</span> (shouldApplyBindings)
            shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, <span class="literal">null</span>, viewModel, bindingContextMayDifferFromDomParentElement).shouldBindDescendants;

        <span class="keyword">if</span> (shouldBindDescendants) {</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>We&#39;re recursing automatically into (real or virtual) child nodes without changing binding contexts. So,
 <em> For children of a </em>real<em> element, the binding context is certainly the same as on their DOM .parentNode,
   hence bindingContextsMayDifferFromDomParentElement is false
 </em> For children of a <em>virtual</em> element, we can&#39;t be sure. Evaluating .parentNode on those children may
   skip over any number of intermediate virtual elements, any of which might define a custom binding context,
   hence bindingContextsMayDifferFromDomParentElement is true</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            applyBindingsToDescendantsInternal(viewModel, nodeVerified, <span class="comment">/* bindingContextsMayDifferFromDomParentElement: */</span> !isElement);
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">applyBindingsToNodeInternal</span> <span class="params">(node, bindings, viewModelOrBindingContext, bindingContextMayDifferFromDomParentElement)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Need to be sure that inits are only run once, and updates never run until all the inits have been run</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> initPhase = <span class="number">0</span>; <span class="comment">// 0 = before all inits, 1 = during inits, 2 = after all inits</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Each time the dependentObservable is evaluated (after data changes),
the binding attribute is reparsed so that it can pick out the correct
model properties in the context of the changed data.
DOM event callbacks need to be able to access this changed data,
so we need a single parsedBindings variable (shared by all callbacks
associated with this node&#39;s bindings) that all the closures can access.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> parsedBindings;
        <span class="function"><span class="keyword">function</span> <span class="title">makeValueAccessor</span><span class="params">(bindingKey)</span> {</span>
            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="keyword">return</span> parsedBindings[bindingKey] }
        }
        <span class="function"><span class="keyword">function</span> <span class="title">parsedBindingsAccessor</span><span class="params">()</span> {</span>
            <span class="keyword">return</span> parsedBindings;
        }

        <span class="keyword">var</span> bindingHandlerThatControlsDescendantBindings;
        ko.dependentObservable(
            <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Ensure we have a nonnull binding context to work with</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> bindingContextInstance = viewModelOrBindingContext &amp;&amp; (viewModelOrBindingContext <span class="keyword">instanceof</span> ko.bindingContext)
                    ? viewModelOrBindingContext
                    : <span class="keyword">new</span> ko.bindingContext(ko.utils.unwrapObservable(viewModelOrBindingContext));
                <span class="keyword">var</span> viewModel = bindingContextInstance[<span class="string">'$data'</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Optimization: Don&#39;t store the binding context on this node if it&#39;s definitely the same as on node.parentNode, because
we can easily recover it just by scanning up the node&#39;s ancestors in the DOM
(note: here, parent node means &quot;real DOM parent&quot; not &quot;virtual parent&quot;, as there&#39;s no O(1) way to find the virtual parent)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (bindingContextMayDifferFromDomParentElement)
                    ko.storedBindingContextForNode(node, bindingContextInstance);</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Use evaluatedBindings if given, otherwise fall back on asking the bindings provider to give us some bindings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> evaluatedBindings = (<span class="keyword">typeof</span> bindings == <span class="string">"function"</span>) ? bindings(bindingContextInstance, node) : bindings;
                parsedBindings = evaluatedBindings || ko.bindingProvider[<span class="string">'instance'</span>][<span class="string">'getBindings'</span>](node, bindingContextInstance);

                <span class="keyword">if</span> (parsedBindings) {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>First run all the inits, so bindings can register for notification on changes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">if</span> (initPhase === <span class="number">0</span>) {
                        initPhase = <span class="number">1</span>;
                        <span class="keyword">for</span> (<span class="keyword">var</span> bindingKey <span class="keyword">in</span> parsedBindings) {
                            <span class="keyword">var</span> binding = ko.bindingHandlers[bindingKey];
                            <span class="keyword">if</span> (binding &amp;&amp; node.nodeType === <span class="number">8</span>)
                                validateThatBindingIsAllowedForVirtualElements(bindingKey);

                            <span class="keyword">if</span> (binding &amp;&amp; <span class="keyword">typeof</span> binding[<span class="string">"init"</span>] == <span class="string">"function"</span>) {
                                <span class="keyword">var</span> handlerInitFn = binding[<span class="string">"init"</span>];
                                <span class="keyword">var</span> initResult = handlerInitFn(node, makeValueAccessor(bindingKey), parsedBindingsAccessor, viewModel, bindingContextInstance);</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>If this binding handler claims to control descendant bindings, make a note of this</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                <span class="keyword">if</span> (initResult &amp;&amp; initResult[<span class="string">'controlsDescendantBindings'</span>]) {
                                    <span class="keyword">if</span> (bindingHandlerThatControlsDescendantBindings !== <span class="literal">undefined</span>)
                                        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Multiple bindings ("</span> + bindingHandlerThatControlsDescendantBindings + <span class="string">" and "</span> + bindingKey + <span class="string">") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element."</span>);
                                    bindingHandlerThatControlsDescendantBindings = bindingKey;
                                }
                            }
                        }
                        initPhase = <span class="number">2</span>;
                    }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>... then run all the updates, which might trigger changes even on the first evaluation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">if</span> (initPhase === <span class="number">2</span>) {
                        <span class="keyword">for</span> (<span class="keyword">var</span> bindingKey <span class="keyword">in</span> parsedBindings) {
                            <span class="keyword">var</span> binding = ko.bindingHandlers[bindingKey];
                            <span class="keyword">if</span> (binding &amp;&amp; <span class="keyword">typeof</span> binding[<span class="string">"update"</span>] == <span class="string">"function"</span>) {
                                <span class="keyword">var</span> handlerUpdateFn = binding[<span class="string">"update"</span>];
                                handlerUpdateFn(node, makeValueAccessor(bindingKey), parsedBindingsAccessor, viewModel, bindingContextInstance);
                            }
                        }
                    }
                }
            },
            <span class="literal">null</span>,
            { disposeWhenNodeIsRemoved : node }
        );

        <span class="keyword">return</span> {
            shouldBindDescendants: bindingHandlerThatControlsDescendantBindings === <span class="literal">undefined</span>
        };
    };

    <span class="keyword">var</span> storedBindingContextDomDataKey = <span class="string">"__ko_bindingContext__"</span>;
    ko.storedBindingContextForNode = <span class="function"><span class="keyword">function</span> <span class="params">(node, bindingContext)</span> {</span>
        <span class="keyword">if</span> (arguments.length == <span class="number">2</span>)
            ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);
        <span class="keyword">else</span>
            <span class="keyword">return</span> ko.utils.domData.get(node, storedBindingContextDomDataKey);
    }

    ko.applyBindingsToNode = <span class="function"><span class="keyword">function</span> <span class="params">(node, bindings, viewModel)</span> {</span>
        <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) <span class="comment">// If it's an element, workaround IE &lt;= 8 HTML parsing weirdness</span>
            ko.virtualElements.normaliseVirtualElementDomStructure(node);
        <span class="keyword">return</span> applyBindingsToNodeInternal(node, bindings, viewModel, <span class="literal">true</span>);
    };

    ko.applyBindingsToDescendants = <span class="keyword">function</span>(viewModel, rootNode) {
        <span class="keyword">if</span> (rootNode.nodeType === <span class="number">1</span> || rootNode.nodeType === <span class="number">8</span>)
            applyBindingsToDescendantsInternal(viewModel, rootNode, <span class="literal">true</span>);
    };

    ko.applyBindings = <span class="function"><span class="keyword">function</span> <span class="params">(viewModel, rootNode)</span> {</span>
        <span class="keyword">if</span> (rootNode &amp;&amp; (rootNode.nodeType !== <span class="number">1</span>) &amp;&amp; (rootNode.nodeType !== <span class="number">8</span>))
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node"</span>);
        rootNode = rootNode || window.document.body; <span class="comment">// Make "rootNode" parameter optional</span>

        applyBindingsToNodeAndDescendantsInternal(viewModel, rootNode, <span class="literal">true</span>);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Retrieving binding context from arbitrary nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    ko.contextFor = <span class="keyword">function</span>(node) {</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can&#39;t store domdata for them)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">switch</span> (node.nodeType) {
            <span class="keyword">case</span> <span class="number">1</span>:
            <span class="keyword">case</span> <span class="number">8</span>:
                <span class="keyword">var</span> context = ko.storedBindingContextForNode(node);
                <span class="keyword">if</span> (context) <span class="keyword">return</span> context;
                <span class="keyword">if</span> (node.parentNode) <span class="keyword">return</span> ko.contextFor(node.parentNode);
                <span class="keyword">break</span>;
        }
        <span class="keyword">return</span> <span class="literal">undefined</span>;
    };
    ko.dataFor = <span class="keyword">function</span>(node) {
        <span class="keyword">var</span> context = ko.contextFor(node);
        <span class="keyword">return</span> context ? context[<span class="string">'$data'</span>] : <span class="literal">undefined</span>;
    };

    ko.exportSymbol(<span class="string">'bindingHandlers'</span>, ko.bindingHandlers);
    ko.exportSymbol(<span class="string">'applyBindings'</span>, ko.applyBindings);
    ko.exportSymbol(<span class="string">'applyBindingsToDescendants'</span>, ko.applyBindingsToDescendants);
    ko.exportSymbol(<span class="string">'applyBindingsToNode'</span>, ko.applyBindingsToNode);
    ko.exportSymbol(<span class="string">'contextFor'</span>, ko.contextFor);
    ko.exportSymbol(<span class="string">'dataFor'</span>, ko.dataFor);
})();</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
